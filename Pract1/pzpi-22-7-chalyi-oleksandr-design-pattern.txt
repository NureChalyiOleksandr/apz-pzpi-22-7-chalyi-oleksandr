МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра ПІ
ЗВІТ
з практичної роботи №1 
з дисципліни «Архітектура програмного забезпечення»




Виконав:                                                                 Перевірив:
Ст. гр. ПЗПІ-22-7                                                         Ст. вик. каф. ПІ
Чалий О. О.                                                         Сокорчук І. П.
Харків 2025
1  ІСТОРІЯ ЗМІН


№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	13.06.2025
	0.1
	Створено розділ «Історія змін»
	2
	13.06.2025
	0.1
	Створено розділ «Завдання»
	3
	13.06.2025
	0.1
	Створено розділ «Опис виконаної роботи»
	4
	13.06.2025
	0.1
	Створено розділ «Висновки»
	5
	13.06.2025
	0.1
	Додано слайди презентації у додаток Б
	6
	13.06.2025
	0.1
	Додано приклади коду у додаток В
	7
	15.06.2025
	0.1
	Додано посилання на відеозапис та хронологічний опис доповіді у додаток А


	

2 ЗАВДАННЯ
1. Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ» (із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone)
2. Створити та оформити слайди презентації доповіді
3. Створити та опублікувати на YouTube відеозапис доповіді
4. Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5. При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6. Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7. Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
8. Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9. Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1
3 ОПИС ВИКОНАНОЇ РОБОТИ
У процесі роботи було досліджено та проаналізовано патерн проєктування "Memento" («Зберігач»). Цей патерн належить до категорії поведінкових шаблонів проєктування, описаних у книзі "Design Patterns" (Gang of Four).
3.1 Вступ до патерна Memento
Memento, відомий також як «Зберігач» - це один із класичних шаблонів проектування, описаних у книзі «Design Patterns». У центрі його уваги — збереження внутрішнього стану об'єкта без порушення його інкапсуляції. Уявіть ситуацію, коли потрібно реалізувати функцію «Скасувати» або «Повернутися назад». Здавалося б, достатньо просто зберегти певну інформацію, але якщо внутрішній стан об'єкта надійно прихований від зовнішнього світу — що цілком нормально — тоді виникає дилема: як зберегти цей стан, не розкриваючи його структуру? Патерн Memento дає відповідь саме на це питання.
3.2 Намір і мета патерна
Головна ідея патерна полягає в тому, щоб зберегти моментальний знімок внутрішнього стану об’єкта і мати змогу в будь-який момент повернути цей об’єкт у попередній стан. При цьому важливо, що сам стан залишається недоступним для інших об'єктів — лише сам власник стану має право працювати з його вмістом. Таким чином, ми уникаємо руйнації інкапсуляції, яка є однією з основ об'єктно-орієнтованого програмування. Це дозволяє гнучко реалізовувати функції на кшталт «відміни» останньої дії, збереження контрольних точок або повне відновлення після помилки.
3.3 Мотивація: редактор з прив’язками
Щоб краще зрозуміти потребу в цьому патерні, уявімо собі графічний редактор, у якому можна з'єднувати об'єкти — наприклад, прямокутники — лініями. Коли один з них рухається, лінія змінює форму, щоб зберегти з'єднання. За цим стоїть складна система обчислень — так званий ConstraintSolver. Але що станеться, якщо користувач захоче повернути об'єкт назад? Просте переміщення на попередню відстань не гарантує, що всі зв'язки будуть відновлені правильно. Саме тому потрібен механізм, який дозволить не просто перемістити об’єкт, а повністю повернути систему обмежень до попереднього стану. І тут вступає в гру Memento.
3.4 Як працює Memento у прикладі
Розглянемо процес: перед переміщенням об'єкта редактор просить ConstraintSolver створити Memento — тобто зберегти поточний стан. Цей знімок зберігається у зовнішній системі, наприклад, у стеку скасування дій. Коли користувач натискає «Undo», цей знімок повертається назад до ConstraintSolver, і той відновлює своє попереднє внутрішнє положення. Таким чином, ми отримуємо надійний механізм відновлення, не вдаючись до втручання у внутрішню логіку чи структуру даних, і зберігаючи коректність зв’язків між об’єктами.
3.5 Учасники взаємодії у шаблоні
Весь механізм реалізовано через три ролі. Перший — це Originator, тобто об'єкт, що має стан і вміє створювати та відновлювати Memento. У нашому прикладі це ConstraintSolver. Другий — власне сам Memento, який зберігає стан, але не дозволяє нікому, окрім Originator’а, бачити або змінювати його вміст. І нарешті, третій — Caretaker, який є посередником: він лише зберігає Memento і не намагається його читати чи змінювати. Це як секретний лист у запечатаному конверті: тільки відправник і одержувач знають, що всередині, решта — лише зберігають його в надійному місці.
3.6 Взаємодія між об'єктами
Уся взаємодія виглядає наступним чином. Originator створює Memento, передає його Caretaker’у, який бере на себе обов’язок тимчасового зберігання. Згодом, коли виникає потреба відновити попередній стан, Caretaker повертає Memento назад, і Originator відновлюється, використовуючи лише ті дані, які сам же раніше і поклав до збереження. У цьому процесі важливо, що жодна з ролей не виходить за свої межі: кожен об’єкт знає тільки те, що йому дозволено знати.
3.7 Переваги використання патерна
До основних переваг цього підходу належить, насамперед, збереження інкапсуляції. Внутрішня логіка Originator’а залишається повністю прихованою — інші об’єкти не мають до неї доступу. Завдяки цьому патерн підходить для проєктів, де важливо мінімізувати зв’язність між компонентами. До того ж, сам Originator не повинен більше турбуватися про збереження історії змін — цю відповідальність він делегує іншим об'єктам. Це спрощує його структуру і розвантажує від зайвих обов’язків.
3.8 Можливі складнощі
Однак, як і будь-який інструмент, патерн Memento має свої обмеження. По-перше, збереження великих обсягів стану може бути дорогим за ресурсами. Якщо часто створюються копії великого об'єкта — це може суттєво вплинути на продуктивність. По-друге, реалізувати подвійну видимість — «вузький» інтерфейс для збереження і «широкий» для відновлення — не завжди просто, особливо у мовах, де немає розвинених механізмів доступу. Крім того, є й приховані витрати: Caretaker не знає, скільки даних він фактично зберігає, але все одно повинен подбати про управління пам’яттю.
3.9 Приклад реалізації
Щоб зрозуміти, як це виглядає у коді, розгляньмо приклад на C++. Припустімо, у нас є команда MoveCommand, яка переміщує об'єкт. Перед виконанням вона запитує у ConstraintSolver мітку стану — об’єкт типу Memento. Далі об'єкт переміщується, а система обмежень перераховується. Якщо потрібно скасувати дію — ми просто викликаємо збережений Memento, передаємо його назад ConstraintSolver’у, і той повертається до попереднього стану. Це дозволяє реалізувати дуже точну і передбачувану операцію «Undo».
3.10 Завершення і значення патерна
У підсумку, патерн Memento — це потужний інструмент, який дозволяє поєднати збереження стану з дотриманням принципів об’єктної орієнтації. Його можна застосовувати не лише для скасування дій, а й для збереження проміжних станів, реалізації історії змін, а також навіть у реалізації ітераторів або складних моделей обчислень. Він чудово показує, як грамотно розподіляти відповідальність між об'єктами без порушення їхньої внутрішньої цілісності. І хоча іноді це вимагає додаткових ресурсів, користь у вигляді гнучкості та надійності архітектури цілком це виправдовує.
4 ВИСНОВКИ З РОБОТИ
У результаті проведеного дослідження було детально розглянуто патерн проєктування Memento, його структуру, принципи роботи та сфери застосування. Застосування цього патерна дозволяє ефективно реалізовувати механізми збереження та відновлення стану об’єктів без порушення інкапсуляції. Такий підхід особливо корисний у програмному забезпеченні, де важлива підтримка історії змін або реалізація функціональності "скасування дії". Розуміння та вміння застосовувати патерн Memento сприяє розробці гнучких і масштабованих програмних рішень.
________________


ДОДАТОК А
Відеозапис доповіді на YouTube: https://youtu.be/zQvut3ZTS5M
Хронологічний опис доповіді:
0:00 - Зміст презенації
0:10 - Вступ
0:47 - Мета патерна
1:22 - Мотивація
1:57 - Як працює Memento
2:29 - Учасники взаємодії
3:08 - Взаємодія між об'єктами 
3:37 - Переваги використання
4:06 - Можливі складнощі використання
4:38 - Приклад використання
5:10 - Підсумок
________________


ДОДАТОК Б 
Слайди презентації
  

Рисунок Б.1 – Титульний слайд презентації


  

Рисунок Б.2 – Вступ
  

Рисунок Б.3 – Мета патерна


  

Рисунок Б.4 - Мотивація
  

Рисунок Б.5 - Як працює Memento


  

Рисунок Б.6 - Учаники взаємодії у патерні
  

Рисунок Б.7 - Взаємодія між об’єктами


  

Рисунок Б.8 - Переваги використання патерна
  

Рисунок Б.9 - Можливі складнощі


  

Рисунок Б.10 - Приклад реалізації
  

Рисунок Б.11 - Підсумок




________________


ДОДАТОК В 
Програмний код 
1  // Memento: внутрішній стан Solver’а
2  class ConstraintSolverMemento {
3      friend class ConstraintSolver;
4  private:
5      std::vector<Constraint> constraintsSnapshot;
6      std::map<std::string, Point> objectPositions;
7
8      ConstraintSolverMemento(
9          const std::vector<Constraint>& constraints,
10         const std::map<std::string, Point>& positions
11     ) : constraintsSnapshot(constraints), objectPositions(positions) {
12     }
13 };
14
15 // Originator: Solver, що створює/відновлює Memento
16 class ConstraintSolver {
17 public:
18     void AddConstraint(const Constraint& c) {
19         constraints.push_back(c);
20     }
21
22     void MoveObject(const std::string& id, const Point& delta) {
23         objectPositions[id].x += delta.x;
24         objectPositions[id].y += delta.y;
25     }
26
27     std::shared_ptr<ConstraintSolverMemento> CreateMemento() const {
28         return std::make_shared<ConstraintSolverMemento>(constraints, objectPositions);
29     }
30
31     void Restore(std::shared_ptr<ConstraintSolverMemento> memento) {
32         constraints = memento->constraintsSnapshot;
33         objectPositions = memento->objectPositions;
34     }
35
36 private:
37     std::vector<Constraint> constraints;
38     std::map<std::string, Point> objectPositions;
39 };
40
41 // Caretaker + Command: виконує дію і дозволяє її скасувати
42 class MoveCommand {
43 public:
44     MoveCommand(ConstraintSolver& solver, const std::string& objectId, Point delta)
45         : solver(solver), objectId(objectId), delta(delta) {
46     }
47
48     void Execute() {
49         backup = solver.CreateMemento(); // збереження стану перед зміною
50         solver.MoveObject(objectId, delta);
51     }
52
53     void Undo() {
54         if (backup) {
55             solver.Restore(backup); // відкат до попереднього стану
56         }
57     }
58
59 private:
60     ConstraintSolver& solver;
61     std::string objectId;
62     Point delta;
63     std::shared_ptr<ConstraintSolverMemento> backup;
64 };